# -正则捕获组和非捕获组


正则表达式中如果对于单字符捕获可以使用限字符，如果对于多字符呢？对，用小括号，用小括号包裹指定的字符，这就是分组，后面再加上限制这个字符出现的次数

每个分组会自动拥有一个组号，从左到右，以分组的左括号为标志，第一个分组组号为1，依次递增。


捕获例子参见代码 - > main.js 


引发非捕获组的学习
有两个金额：6000￥ 和 1000$。 现在需要得到金额和货币种类

废话少说，直接上正则   (\d+)([$￥])    // s1 = 1000, s2 = $
满足了需求，一个是(\d+),一个是([$￥])

现在需求变了，我需要这个正则同时可以匹配浮点数小数点前面的整数,如10010.86￥，提炼出 10010 和 ￥。
同样正则 (\d+)(\.?)(\d+)([$￥])   // s1 = 10010, s2 = . , s3 = 86, s4 = $

如果通过不修改代码而让 捕获组 s1 = 10010 , s2 = $ 呢？ 这时候就需要引入非捕获组
把前面的正则修改为如下：
(\d+)(?:\.?)(?:\d+)([$￥])  //s1 = 10010 , s2 = $


可以理解为只分组不捕获


二：(?=)和(?<=) 前后查找

例子：

var str = '123aa4556aa';
正则  (\d+)(?=aa)  // 捕获内容为 123,4556
深入理解一下，第一次捕获是123，因为 ?= 是非捕获，所以会痛23后第一个字符继续开始查找，然后找到4556

特例说明：
(?=hopeful)hope == hope(?=ful)


下面说一下 ?<= 这个匹配前面是什么内容

例子：
var str = '1111aa23dfaa';
正则  (?<=aa)([0-9a-z]{2}); //23


三：(?!)和(?<!) 逆袭!
已上面类型，只不过是把 = 换成了!,那么意义刚好也是相反的

(\d+)(?!aa)  //捕获后面不是紧跟aa

(?<!aa)([0-9a-z]{2}); //捕获前面不是紧跟aa


